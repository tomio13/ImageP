#!/usr/bin/env python
""" ImageP.Kernels: Kernel functions and definitions. 
        There are several possibilities, depending on what one wants.

    Author: Tamas Haraszti, Biophysical Chemistry group at the University of
        Heidelberg

    Copyright:	LGPL-3
    Warranty:	For any application, there is no warranty 8).

"""

from numpy import zeros, asarray, arange, indices, log, exp, sqrt, abs

#######################################################
# List of functions defined / exported here:
__all__=['BoxcarKernel', 'BinomKernel', 'CircMask',\
        'GaussKernel', 'SoebelKernel', 'BallKernel']

def GaussKernel(r=10, width=0, FWHM=0, norm=True, OneD=False):
    """Generate a 2D matrix with 2r+1 size containing a
        normalized Gaussian function:

        	exp(-4*ln(2)*(x-r)^2/FWHM^2)/sum
            or
            exp(- (x-r)^2/(2*width^2)) / sum

        The width is the standard deviation of the normal distribution.

        The FWHM is the full width (-x to +x) at the half maximum
        of the curve. If width is specified, it is the half distance
        of the two inflection points of the curve.
        FWHM = 2*sqrt(2 * ln(2))*width
        
        norm:   is used to normalize to unit sum of the curve.
        OneD:     if True, return only a 1D array

        return:
        	an image containing with the 2D gaussian
    """

    size = 2*r+1

    if width == 0 and FWHM == 0:
        #set width to r:
        const = -1.0/(2.0*r**2)

    elif width == 0:
        # for FWHM:the Gaussian is exp(-4 ln(2)(x-x0)^2 / sigma^2)
        const = -4.0*log(2.0)/(FWHM**2)
    else:
        #or exp(-(x-r)^2/(2*sigma^2))
        const = -1.0/(2.0*width**2)
    #end if
 
    #do it in OneD:
    kernelcore = arange(size, dtype=float)
    kernel1 = exp(const*((kernelcore - r)**2))

    if not OneD:
        kernel2 = kernel1.copy()
        # a special transpose to make outer multiplication possible:
        kernel2.shape = (kernel1.shape[0],1)
        #now this gets a 2D array of k[i,j] = a[0,i]*b[j,0]
        kernel = kernel1*kernel2
    else:
        kernel = kernel1.copy()
    #Utilize the two index matrices generated by mgrid:
#    kernelcore = indices((size,size),dtype=float)
    
#    kernel = exp(const*((kernelcore[0]-r)**2 +(kernelcore[1]-r)**2))

    if norm:
        #Normalize to 1:
        kernel = kernel/kernel.sum()
    
    return kernel
#End of GaussKernel


def CircMask(r=10, norm=True):
    """ Create a circular mask with radius r
        Actually, the same as BoxcarKernel, but with a circular shape.

        if norm then normalize the sum to 1.0
        (There is no 1D version)
    """

    size = 2*r + 1
    
    core = indices((size,size),dtype=int)
    circle = ((core[0] - r)**2 + (core[1]-r)**2 ) < (r*r)
    circle = circle.astype(float)

    if norm:
        return circle/circle.sum()

    else :
        return circle
#End of CircleMask()

def BoxcarKernel(r=10, norm=True, OneD=False):
    """A constant kernel for smoothing images.
       Parameters:
       	r the radius of the structure. The image size is 2r+1
        norm Normalize to one or not? If True, divides the image
            by the sum of the image. False by default

        If OneD it is just a ones().
    """
    #We need an integer value:
    r = int(r)
    size = 2*r+ 1
    kernel1 = zeros(size,dtype=float) + 1.0

    if not OneD:
        kernel2 = kernel1.copy()
        kernel2.shape = (kernel1.shape[0],1)
        kernel = kernel1*kernel2
    else:
        kernel = kernel1

    if norm:
        #Normalize to 1:
        kernel = kernel/kernel.sum()
    
    return kernel
#End of BoxcarKernel()


def BinomKernel(N, norm= True, OneD=False):
    """generate a binomial kernel
        N = 1 -> [1]
        N = 2 -> [1,1] -> [[1,1],[1,1]]
        N = 3 -> [1,2,1] -> [[ 1.,  2.,  1.],
                            [ 2.,  4.,  2.],
                            [ 1.,  2.,  1.]]
        etc.

        if norm is True, normalize the sum to 1.0
        if OneD is True, return a 1D array only
        
        Return value: the kernel matrix.
    """

    if N<1 :
        print "positive integer is expected (N>0)"
        return None
    #end if
    a = asarray([])
    for i in xrange(1,N+1):
        b = zeros(i)
        b[0] = b[-1] = 1

        if a.size > 0 :
            b[1:-1] = a[1:] + a[:-1]
        #end if
        a = b.copy()
    #end for
    if not OneD:
        c = b.copy()
        c.shape=(b.shape[0],1)
        res = b*c
    else:
        res = b
    #end if

    if norm:
        return res/res.sum()
    else:
        return res
#end Binomial


def SoebelKernel(N=3, X=True):
    """ Define a Soebel kernel. 
        This is far from ideal at the moment, a better implementation is needed.
        For the 3x3 version it uses the optimized version from Scharr 
        (Digital Image Processing by Jahne et al.).

        The others are just a simple variant, which may be far from optimal.

        Since this kernel is either X or Y direction,
        one can specify which to use.
        N:  3, 5, 7, or 9
        X:  Bool (True) for the X direction filter, False for Y direction

        return:
        a matrix containing the kernel
    """
    if N > 9 or N < 3 :
        print " 3 <= N <= 9 are implemented. Falling back to N=3"
        N = 3
    #end if

    if N == 3 :
        res = asarray([[3,10,3],[0,0,0],[-3,-10,-3]])
    elif N == 5:
        res = asarray([[1,2,3,2,1],\
                    [2,3,4,3,2],\
                    [0,0,0,0,0],\
                    [-2,-3,-4,-3,-2],\
                    [-1,-2,-3,-2,-1 ]])
    elif N == 7 :
        res = asarray([[1,2,3,4,3,2,1],\
                    [2,3,4,5,4,3,2],\
                    [3,4,5,6,5,4,3],\
                    [0,0,0,0,0,0,0],\
                    [-3,-4,-5,-6,-5,-4,-3],\
                    [-2,-3,-4,-5,-4,-3,-2],\
                    [-1,-2,-3,-4,-3,-2,-1 ]])
    elif N == 9:
        res = asarray([[1,2,3,4,5,4,3,2,1],\
                    [2,3,4,5,6,5,4,3,2],\
                    [3,4,5,6,7,6,5,4,3],\
                    [4,5,6,7,8,7,6,5,4],\
                    [0,0,0,0,0,0,0,0,0],\
                    [-4,-5,-6,-7,-8,-7,-6,-5,-4],\
                    [-3,-4,-5,-6,-7,-6,-5,-4,-3],\
                    [-2,-3,-4,-5,-6,-5,-4,-3,-2],\
                    [-1,-2,-3,-4,-5,-4,-3,-2,-1 ]])
    else:
        print "Invalid N, please use one from: 3,5,7,9"
        return None
        
    #normalize:
    res = res.astype('f')/(abs(res)).sum()

    if X:
        return res.transpose()
    else :
        return res
#end of SoebelKernel

def BallKernel(r1, r2=0, norm=False, OneD=False):
    """ Make a ball kernel with window 2r1+1 and
        radius r2.
        If r2 not specified, use r1.
    """
    if r2 <= 0.0:
           r2 = r1
    #end if
    if r1 <= 0.0:
        raise ValueError
 
    rsquare = r2*r2
    width = int( 2*r1 + 1.5) #we use +0.5 for rounding
    x = arange(width, dtype= 'f')

    #The center is the middle of width, defined by r1
    x = x - r1
    #make it quadratic:
    x = x*x 

    if OneD:
        kernel = rsquare - x
        kernel[ kernel < 0.0 ] = 0.0
        k = sqrt(kernel)
        if norm:
            k = k / k.sum()
        return k

        
    #now make a col vector:
    y = x.copy()
    y.shape = (x.shape[0],1)

    #x+y will generate a matrix with the quadratic values
    xy = x + y
    kernel = rsquare - xy
    kernel[ kernel < 0.0 ] = 0.0

    if norm:
        k = sqrt(kernel)
        return k/k.sum()
    else:
        return sqrt(kernel)
#end of BallKernel
